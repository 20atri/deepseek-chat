我在使用过程中发现还是有一些bug存在，和需要改进的地方，请你在保证其他所有核心内容不变的情况下，将改后的三串代码（js，html，css）的完整源代码发送给我，并且打上对应功能的标注：
【bug】：
1.在ai返回内容的时候，界面ui滑轮会强制锁定到聊天界面最底部，导致不能一边观看流式输出一边生成消息。
2.删除对话速度过慢，有4段对话，想修改重新生成第一段对话得删除七八次。

【修改和优化】：
1.ai输出内容时不需要强制锁定到最底部的聊天界面，仅在滚动条默认在最底端的时候才自动下拉。
2.在点击重新生成按钮后，自动删除该对话后面的多余对话，但是需要增加额外的提醒图框确定。
3.我需要在设置界面新增加几个可以修改的参数，包括：
温度（Temperature-已集成）：控制生成文本的随机性，值越高输出越随机，值越低输出越确定。
最大令牌数（Max Tokens）：限制生成文本的长度。
停止符（Stop Sequences）：指定生成文本的停止条件，如遇到特定字符或字符串时停止。
频率惩罚（Frequency Penalty-已集成）和存在惩罚（Presence Penalty）：分别用于减少重复和鼓励多样性。
核采样top_p：作用：从累积概率超过阈值p的最小候选词集合中随机选择，动态控制候选词范围
Top-k：固定选择前k个词	候选词数量固定	需要严格控制多样性时（如故事生成）
最小p	直接过滤概率＜p的词	基于概率阈值过滤	剔除低质量候选词（技术性文本生成）
【源代码如下】：
html：

<!DOCTYPE html>

<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeepSeek Chat</title>
    <link rel="stylesheet" href="style.css">
    <!-- 引入 Font Awesome 图标库 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
</head>
<body>
    <div class="app-container">
        <!-- 聊天区域 -->
        <div class="chat-area">
            <div class="chat-header">
                 <!-- 设置按钮 -->
                 <button id="settings-button" title="设置">
                    <i class="fas fa-cog"></i>
                </button>
            </div>
            <div id="chat-container">
                <!-- 消息将在这里动态添加 -->
            </div>

<div id="message-input-container">
            <textarea id="user-input" placeholder="输入你的消息..." rows="1"></textarea> <!-- 初始改为1行，自动增高 -->
            <button id="send-button" title="发送">
                <i class="fas fa-paper-plane"></i>
            </button>
        </div>

        <div class="storage-controls">
             <button id="save-button" title="保存对话">
                <i class="fas fa-save"></i> 保存
            </button>
            <label for="load-input" class="load-button" title="加载对话">
                <i class="fas fa-upload"></i> 加载
            </label>
            <input type="file" id="load-input" accept=".json" style="display: none;">
             <button id="clear-button" title="清空对话">
                 <i class="fas fa-trash-alt"></i> 清空
             </button>
        </div>
    </div>
</div>

<!-- 设置模态弹窗 -->
<div id="settings-modal" class="modal">
    <div class="modal-content">
        <span class="close-button" title="关闭">×</span>
        <h2>设置</h2>
        <div class="setting-item">
            <label for="api-key">API Key:</label>
            <input type="password" id="api-key" placeholder="输入你的 DeepSeek API Key">
        </div>
        <div class="setting-item">
            <label for="model-select">模型:</label>
            <select id="model-select">
                <option value="deepseek-chat">deepseek-chat</option>
                <option value="deepseek-reasoner" selected>deepseek-reasoner</option>
            </select>
        </div>
        <div class="setting-item">
            <label for="temperature">Temperature (<span id="temp-value">0.7</span>):</label>
            <input type="range" id="temperature" min="0" max="2" step="0.1" value="0.7">
        </div>
        <div class="setting-item">
            <label for="frequency-penalty">重复惩罚 (<span id="penalty-value">0.5</span>):</label>
            <input type="range" id="frequency-penalty" min="0" max="2" step="0.1" value="0.5">
        </div>

        <!-- 新增：预设提示词选择 -->
        <div class="setting-item">
            <label for="predefined-prompt-select">选择提示词模板:</label>
            <select id="predefined-prompt-select">
                <!-- 选项将由 JavaScript 动态填充 -->
            </select>
        </div>

        <!-- 现有：自定义系统提示词 -->
        <div class="setting-item">
            <label for="system-prompt">系统提示词 (System Prompt):</label>
            <textarea id="system-prompt" rows="4" placeholder="选择上方的模板或在此处输入自定义提示词"></textarea>
        </div>

         <div class="setting-item">
             <label>
                <input type="checkbox" id="reasoning-default-visible" checked> 默认显示思维链
             </label>
        </div>
    </div>
</div>

<script src="script.js"></script>

</body>
</html>


js：// --- 全局变量和常量 ---
const chatContainer = document.getElementById('chat-container');
const userInput = document.getElementById('user-input');
const sendButton = document.getElementById('send-button');
const saveButton = document.getElementById('save-button');
const loadInput = document.getElementById('load-input');
const clearButton = document.getElementById('clear-button');
const settingsButton = document.getElementById('settings-button');
const settingsModal = document.getElementById('settings-modal');
const closeModalButton = settingsModal.querySelector('.close-button');

// 设置项元素
const apiKeyInput = document.getElementById('api-key');
const modelSelect = document.getElementById('model-select');
const temperatureSlider = document.getElementById('temperature');
const tempValueSpan = document.getElementById('temp-value');
const frequencyPenaltySlider = document.getElementById('frequency-penalty');
const penaltyValueSpan = document.getElementById('penalty-value');
const predefinedPromptSelect = document.getElementById('predefined-prompt-select');
const systemPromptInput = document.getElementById('system-prompt');
const reasoningDefaultVisibleCheckbox = document.getElementById('reasoning-default-visible');

const DEEPSEEK_API_BASE_URL = 'https://api.deepseek.com';

// --- 预设提示词数据 ---
const predefinedPrompts = [
{ name: "默认助理 (通用)", content: "You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe. Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature.\n\nIf a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you don't know the answer to a question, please don't share false information." },
{ name: "周报生成器", content: "你是一个周报生成助手，根据用户提供的工作内容，生成一份简洁、专业的周报。请注意使用书面语，突出重点，条理清晰。" },
];
const customPromptValue = "custom";

let messages = []; // 对话历史核心数据
let currentAssistantMessageId = null; // 当前 AI 消息 ID
let currentAssistantMessageDiv = null; // 当前 AI 消息 DOM
let currentReasoningDiv = null; // 当前思维链 DOM
let currentContentDiv = null; // 当前内容 DOM
let currentAbortController = null; // 中断控制器

// --- 初始化 ---
document.addEventListener('DOMContentLoaded', () => {
console.log("文档加载完成，开始初始化...");
populatePredefinedPrompts();
loadSettings();
loadConversationFromLocalStorage();
addEventListeners();
updateSliderValue(temperatureSlider, tempValueSpan);
updateSliderValue(frequencyPenaltySlider, penaltyValueSpan);
adjustTextareaHeight(userInput);
handlePredefinedPromptChange();
console.log("初始化完成.");
});

// --- 填充预设提示词 ---
function populatePredefinedPrompts() {
predefinedPrompts.forEach((prompt, index) => {
const option = document.createElement('option');
option.value = index.toString();
option.textContent = prompt.name;
predefinedPromptSelect.appendChild(option);
});
const customOption = document.createElement('option');
customOption.value = customPromptValue;
customOption.textContent = "自定义...";
predefinedPromptSelect.appendChild(customOption);
}

// --- 事件监听器 ---
function addEventListeners() {
sendButton.addEventListener('click', handleSendMessage);
userInput.addEventListener('keydown', (e) => {
if (e.key === 'Enter' && !e.shiftKey) {
e.preventDefault();
handleSendMessage();
}
});
userInput.addEventListener('input', () => adjustTextareaHeight(userInput));
saveButton.addEventListener('click', saveConversationToFile);
loadInput.addEventListener('change', loadConversationFromFile);
clearButton.addEventListener('click', clearConversation);
settingsButton.addEventListener('click', openSettingsModal);
closeModalButton.addEventListener('click', closeSettingsModal);
settingsModal.addEventListener('click', (event) => {
if (event.target === settingsModal) closeSettingsModal();
});
predefinedPromptSelect.addEventListener('change', handlePredefinedPromptChange);
predefinedPromptSelect.addEventListener('change', saveSettings);
apiKeyInput.addEventListener('change', saveSettings);
modelSelect.addEventListener('change', saveSettings);
temperatureSlider.addEventListener('input', () => { updateSliderValue(temperatureSlider, tempValueSpan); saveSettings(); });
frequencyPenaltySlider.addEventListener('input', () => { updateSliderValue(frequencyPenaltySlider, penaltyValueSpan); saveSettings(); });
systemPromptInput.addEventListener('change', saveSettings);
reasoningDefaultVisibleCheckbox.addEventListener('change', saveSettings);
chatContainer.addEventListener('click', handleMessageActions);
}

// --- 处理预设提示词选择 ---
function handlePredefinedPromptChange() {
const selectedValue = predefinedPromptSelect.value;
if (selectedValue === customPromptValue) {
systemPromptInput.disabled = false;
systemPromptInput.placeholder = "在此输入自定义提示词...";
systemPromptInput.focus();
} else {
const index = parseInt(selectedValue, 10);
if (!isNaN(index) && index >= 0 && index < predefinedPrompts.length) {
systemPromptInput.value = predefinedPrompts[index].content;
systemPromptInput.disabled = true;
systemPromptInput.placeholder = "使用上方选择的模板";
adjustTextareaHeight(systemPromptInput);
} else {
console.warn("无效预设索引:", selectedValue);
systemPromptInput.disabled = false;
systemPromptInput.placeholder = "选择模板或自定义...";
}
}
}

// --- 核心功能 ---

/**

处理发送消息 (增加按钮禁用检查)
*/
async function handleSendMessage() {
if (sendButton.disabled) {
console.log("正在等待响应，请稍候...");
return; // 阻止发送
}

const userText = userInput.value.trim();
if (!userText) return;

const apiKey = apiKeyInput.value.trim();
if (!apiKey) {
alert("请点击设置按钮 ⚙️ 输入 API Key。");
openSettingsModal();
return;
}

// 1. 添加用户消息到数据和 UI
const userMessage = { id: generateUniqueId('user'), role: 'user', content: userText };
messages.push(userMessage);
appendMessageToUI(userMessage);
saveConversationToLocalStorage(); // 保存用户消息

// 2. 清理输入框并禁用发送按钮
userInput.value = '';
adjustTextareaHeight(userInput);
scrollChatToBottom();
toggleSendButton(false);

// 3. 发送请求
try {
await sendRequestToDeepSeekAPI();
} catch (error) {
console.error("发送或处理请求出错:", error);
if (error.name !== 'AbortError') {
appendErrorMessageToUI("与 DeepSeek API 通信出错: " + error.message);
} else {
console.log("请求被中止。");
}
// 出错时，确保 finally 块会执行以重置状态和按钮
}
// 状态清理和按钮启用现在完全由 sendRequestToDeepSeekAPI 的 finally 处理
}

/**

发送请求到 DeepSeek API (修改点：立即添加 AI 占位符到 messages)
*/
async function sendRequestToDeepSeekAPI() {
const apiKey = apiKeyInput.value.trim();
const model = modelSelect.value;
const temperature = parseFloat(temperatureSlider.value);
const frequency_penalty = parseFloat(frequencyPenaltySlider.value);
const systemPrompt = systemPromptInput.value.trim();

// --- 构建发送给 API 的消息列表 ---
let apiMessages = messages.map(({ role, content }) => ({ role, content }));
// 添加 system prompt (如果需要)
if (systemPrompt) {
if (apiMessages.length === 0 || apiMessages[0].role !== 'system') {
apiMessages.unshift({ role: 'system', content: systemPrompt });
} else {
apiMessages[0].content = systemPrompt; // 更新现有的 system prompt
}
}
// 移除可能存在的连续同角色消息 (防御性)
apiMessages = apiMessages.reduce((acc, current, index, arr) => {
if (index > 0 && current.role === arr[index - 1].role && current.role !== 'system') {
console.warn("过滤连续同角色消息:", arr[index - 1], current);
acc[acc.length - 1] = current; // 保留最后一个
} else {
acc.push(current);
}
return acc;
}, []);

// --- 关键修复点：创建 AI 消息占位符并立即添加到 messages 数组 ---
currentAssistantMessageId = generateUniqueId('assistant');
const assistantMessagePlaceholder = {
id: currentAssistantMessageId,
role: 'assistant',
content: '...', // 初始内容
reasoning_content: ''
};
messages.push(assistantMessagePlaceholder); // 立即添加到核心数据
saveConversationToLocalStorage(); // 保存包含占位符的状态
// --- 修复点结束 ---

// 添加占位符到 UI (这会设置 currentAssistantMessageDiv 等变量)
appendMessageToUI(assistantMessagePlaceholder, true);

currentAbortController = new AbortController();
const signal = currentAbortController.signal;

try {
console.log("发送请求:", { model, messagesCount: apiMessages.length, temperature, frequency_penalty });
const response = await fetch(${DEEPSEEK_API_BASE_URL}/chat/completions, {
method: 'POST',
headers: { 'Content-Type': 'application/json', 'Authorization': Bearer ${apiKey} },
body: JSON.stringify({ model, messages: apiMessages, temperature, frequency_penalty, stream: true }),
signal: signal
});

if (!response.ok) {
     const errorData = await response.json().catch(() => ({}));
     const detail = errorData.error?.message || errorData.message || JSON.stringify(errorData);
     throw new Error(`API 请求失败: ${response.status} ${response.statusText}. ${detail}`);
 }

 await processStream(response.body); // 处理流式数据
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

} catch (error) {
// 处理错误（包括 AbortError）
if (error.name === 'AbortError') {
console.log('Fetch 请求被中止:', error.message);
if (currentContentDiv && document.body.contains(currentContentDiv)) {
currentContentDiv.textContent += " (已中止)";
currentContentDiv.style.opacity = '0.7';
}
} else {
console.error("API 请求或流处理失败:", error);
if (currentContentDiv && document.body.contains(currentContentDiv)) {
currentContentDiv.textContent = 请求错误: ${error.message};
currentContentDiv.style.color = 'red';
} else {
appendErrorMessageToUI(API 请求处理失败: ${error.message});
}
}
// 重新抛出错误，以便外部 catch（如果有）可以感知
throw error;
} finally {
// --- 清理状态 ---
toggleSendButton(true); // 确保按钮最终可用
currentAssistantMessageId = null;
currentAssistantMessageDiv = null;
currentReasoningDiv = null;
currentContentDiv = null;
currentAbortController = null;
scrollChatToBottom();
saveConversationToLocalStorage(); // 保存最终的 messages 状态
console.log("sendRequestToDeepSeekAPI finally block executed.");
}
}

/**

处理 API 返回的流式数据 (修改点：不再 push，只更新)
*/
async function processStream(stream) {
const reader = stream.getReader();
const decoder = new TextDecoder("utf-8");
let buffer = "";
let accumulatedContent = "";
let accumulatedReasoning = "";
let initialChunkReceived = false;
const localMessageId = currentAssistantMessageId; // 捕获当前处理的消息 ID

console.log("开始处理流 for ID:", localMessageId);

// --- 关键：找到 messages 数组中对应的占位符消息的索引 ---
const messageIndex = messages.findIndex(msg => msg.id === localMessageId);
if (messageIndex === -1) {
console.error("严重错误：无法在 messages 数组中找到 ID 为", localMessageId, "的占位符！");
// 可能已被删除或状态异常，停止处理此流
return;
}
// ---

while (true) {
if (currentAbortController && currentAbortController.signal.aborted) {
console.log("检测到中止信号，停止处理流 for ID:", localMessageId);
// 在中止时，也要确保 messages 数组中的内容是当前已累积的
if (messages[messageIndex]) {
messages[messageIndex].content = accumulatedContent + " (已中止)";
messages[messageIndex].reasoning_content = accumulatedReasoning;
}
break;
}

const { done, value } = await reader.read();
 if (done) {
     console.log("流处理完成 for ID:", localMessageId);
     break;
 }

 buffer += decoder.decode(value, { stream: true });
 const lines = buffer.split('\n\n');
 buffer = lines.pop() || "";

 for (const line of lines) {
     if (line.startsWith("data: ")) {
         const dataJson = line.substring(6).trim();
         if (dataJson === "[DONE]") continue;
         try {
             const chunk = JSON.parse(dataJson);
             if (chunk.choices && chunk.choices.length > 0) {
                 const delta = chunk.choices[0].delta;

                 // 检查是否还在处理当前 ID 的消息（虽然理论上 localMessageId 已固定）
                 // if (currentAssistantMessageId !== localMessageId) {
                 //     console.warn("消息 ID 更改，停止更新旧 UI for ID:", localMessageId); return;
                 // }

                  if (!initialChunkReceived && (delta.reasoning_content || delta.content)) {
                     initialChunkReceived = true;
                      if (currentContentDiv && document.body.contains(currentContentDiv) && currentContentDiv.textContent === '...') { // 初始占位符是 '...'
                         currentContentDiv.textContent = '';
                     }
                 }

                 // --- 更新累积内容和 messages 数组 ---
                 if (delta.reasoning_content) {
                     accumulatedReasoning += delta.reasoning_content;
                     // 实时更新 messages 数组中的 reasoning_content
                     if (messages[messageIndex]) {
                         messages[messageIndex].reasoning_content = accumulatedReasoning;
                     }
                     // 更新 UI
                     if (currentReasoningDiv && document.body.contains(currentReasoningDiv)) {
                         currentReasoningDiv.textContent = accumulatedReasoning;
                         const toggle = currentAssistantMessageDiv?.querySelector('.reasoning-toggle');
                         if(toggle && document.body.contains(toggle)) {
                             if (toggle.style.display === 'none') toggle.style.display = 'block';
                             if (!currentReasoningDiv.classList.contains('visible') && reasoningDefaultVisibleCheckbox.checked) {
                                 currentReasoningDiv.classList.add('visible');
                             }
                         }
                     }
                 }
                 if (delta.content) {
                     accumulatedContent += delta.content;
                      // 实时更新 messages 数组中的 content
                      if (messages[messageIndex]) {
                          messages[messageIndex].content = accumulatedContent;
                      }
                      // 更新 UI
                     if (currentContentDiv && document.body.contains(currentContentDiv)) {
                         currentContentDiv.textContent = accumulatedContent;
                     }
                 }
                 // --- 更新结束 ---
             }
              scrollChatToBottom();
              // 可以在这里添加轻微的节流保存，避免过于频繁
              // throttleSaveToLocalStorage();
         } catch (e) {
             console.error("解析流 JSON 失败:", e, "数据:", dataJson);
         }
     }
 }
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

}

// --- 流处理循环结束后 ---
console.log("流结束，最终更新 UI for ID:", localMessageId);

// 确保 messages 数组中的最终状态正确
// (在循环中已经实时更新，这里可以省略，除非有中止情况下的特殊处理)
// if (messages[messageIndex]) {
//    messages[messageIndex].content = accumulatedContent;
//    messages[messageIndex].reasoning_content = accumulatedReasoning;
// } else {
//     console.warn("流结束后消息已不存在于数组中, ID:", localMessageId);
//     return;
// }

// 最终的 UI 更新（例如 Markdown 渲染和 reasoning 显隐）
if (currentContentDiv && document.body.contains(currentContentDiv)) {
renderMarkdown(currentContentDiv, accumulatedContent);
}
if (currentReasoningDiv && document.body.contains(currentReasoningDiv)) {
currentReasoningDiv.textContent = accumulatedReasoning;
const toggle = currentAssistantMessageDiv?.querySelector('.reasoning-toggle');
if (toggle && document.body.contains(toggle)) {
if (!accumulatedReasoning) {
currentReasoningDiv.classList.remove('visible');
currentReasoningDiv.style.display = 'none';
toggle.style.display = 'none';
} else {
currentReasoningDiv.style.display = '';
toggle.style.display = 'block';
}
}
}
// 注意：不需要在这里查找 messageIndex 或 push/更新 messages 数组了
// 也不需要在这里 saveConversationToLocalStorage()，finally 块会做
}

// --- UI 更新 ---

/**

将单条消息添加到聊天界面 (增加 DOM 检查)
*/
function appendMessageToUI(message, isStreaming = false) {
try {
if (!chatContainer || !document.body.contains(chatContainer)) {
console.error("无法添加消息，chatContainer 不可用。"); return;
}

const messageDiv = document.createElement('div');
 messageDiv.classList.add('message', message.role);
 messageDiv.dataset.messageId = message.id;

 const avatar = document.createElement('img');
 avatar.classList.add('avatar');
 avatar.src = message.role === 'user' ? 'user-avatar.png' : 'bot-avatar.png';
 avatar.alt = message.role;
 avatar.onerror = () => { /* 省略默认头像代码 */ };

 const contentWrapper = document.createElement('div');
 contentWrapper.classList.add('message-content-wrapper');

 let reasoningDiv = null;
 let reasoningToggle = null;
 if (message.role === 'assistant') {
     reasoningToggle = document.createElement('span');
     reasoningToggle.classList.add('reasoning-toggle');
     reasoningToggle.textContent = '显示/隐藏 思维链';
     reasoningToggle.dataset.targetId = `reasoning-${message.id}`;
     reasoningToggle.style.display = (message.reasoning_content || isStreaming) ? 'block' : 'none';
     contentWrapper.appendChild(reasoningToggle);

     reasoningDiv = document.createElement('div');
     reasoningDiv.classList.add('reasoning-content');
     reasoningDiv.id = `reasoning-${message.id}`;
     reasoningDiv.textContent = message.reasoning_content || '';
     if ((isStreaming && reasoningDefaultVisibleCheckbox.checked) || (!isStreaming && message.reasoning_content && reasoningDefaultVisibleCheckbox.checked)) {
         reasoningDiv.classList.add('visible');
     }
     if (!isStreaming && !message.reasoning_content) {
         reasoningDiv.style.display = 'none';
     }
     contentWrapper.appendChild(reasoningDiv);
 }

 const messageBubble = document.createElement('div');
 messageBubble.classList.add('message-bubble');
 const actualContentDiv = document.createElement('div');
 actualContentDiv.classList.add('actual-content');

 if (isStreaming && message.role === 'assistant') {
     // 更新全局状态变量以指向新的占位符 DOM 元素
     // currentAssistantMessageId 已在调用此函数前设置
     currentAssistantMessageDiv = messageDiv;
     currentReasoningDiv = reasoningDiv;
     currentContentDiv = actualContentDiv;
     actualContentDiv.textContent = message.content; // 使用占位符的初始内容 '...'
 } else {
     renderMarkdown(actualContentDiv, message.content);
 }

 messageBubble.appendChild(actualContentDiv);
 contentWrapper.appendChild(messageBubble);
 const actionsDiv = createMessageActions(message.id, message.role);
 contentWrapper.appendChild(actionsDiv);
 messageDiv.appendChild(avatar);
 messageDiv.appendChild(contentWrapper);
 chatContainer.appendChild(messageDiv);
 scrollChatToBottom();
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

} catch (error) {
console.error("添加到 UI 时出错:", error, "消息:", message);
appendErrorMessageToUI(渲染消息 ${message.id} 时出错: ${error.message});
}
}

/**

创建消息的操作按钮区域 (无修改)
*/
function createMessageActions(messageId, role) {
const actionsDiv = document.createElement('div');
actionsDiv.classList.add('message-actions');
const editBtn = document.createElement('i');
editBtn.className = 'fas fa-pencil-alt action-icon edit-btn';
editBtn.title = '编辑'; editBtn.dataset.action = 'edit';
actionsDiv.appendChild(editBtn);
const deleteBtn = document.createElement('i');
deleteBtn.className = 'fas fa-trash-alt action-icon delete-btn';
deleteBtn.title = '删除'; deleteBtn.dataset.action = 'delete';
actionsDiv.appendChild(deleteBtn);
if (role === 'assistant') {
const regenerateBtn = document.createElement('i');
regenerateBtn.className = 'fas fa-sync-alt action-icon regenerate-btn';
regenerateBtn.title = '重新生成'; regenerateBtn.dataset.action = 'regenerate';
actionsDiv.appendChild(regenerateBtn);
}
return actionsDiv;
}

/**

将错误信息添加到聊天界面 (无修改)
*/
function appendErrorMessageToUI(errorText) {
try {
const errorDiv = document.createElement('div');
errorDiv.className = 'message error';
errorDiv.style.cssText = 'color: red; background-color: #ffebee; padding: 10px 15px; border: 1px solid #e57373; border-radius: 5px; margin-top: 10px; align-self: center; max-width: 85%;';
errorDiv.textContent = errorText;
if (chatContainer && document.body.contains(chatContainer)) {
chatContainer.appendChild(errorDiv);
scrollChatToBottom();
} else {
console.error("无法添加错误消息，chatContainer 不可用:", errorText);
}
} catch(uiError) {
console.error("添加错误消息时出错:", uiError, "原始错误:", errorText);
}
}

/**

滚动聊天容器到底部 (无修改)
*/
function scrollChatToBottom() {
if (chatContainer) {
setTimeout(() => chatContainer.scrollTop = chatContainer.scrollHeight, 0);
}
}

/**

更新滑块旁边显示的数值 (无修改)
*/
function updateSliderValue(slider, valueSpan) {
if(slider && valueSpan) valueSpan.textContent = slider.value;
}

/**

切换发送按钮的启用/禁用状态 (无修改)
*/
function toggleSendButton(enabled) {
if (sendButton) {
sendButton.disabled = !enabled;
sendButton.style.cursor = enabled ? 'pointer' : 'not-allowed';
sendButton.style.opacity = enabled ? '1' : '0.6';
}
}

/**

动态调整文本输入框的高度 (无修改)
*/
function adjustTextareaHeight(textarea) {
if(textarea) {
textarea.style.height = 'auto';
const scrollHeight = textarea.scrollHeight;
const maxHeight = parseInt(window.getComputedStyle(textarea).maxHeight, 10) || 150;
textarea.style.height = (scrollHeight > maxHeight ? maxHeight : scrollHeight + 2) + 'px';
textarea.style.overflowY = scrollHeight > maxHeight ? 'auto' : 'hidden';
}
}

/**

简单 Markdown 渲染 (无修改)
*/
function renderMarkdown(element, markdownText) {
if(element) element.textContent = markdownText;
}

// --- 消息操作处理 ---

/**

处理消息操作按钮点击 (无修改)
*/
function handleMessageActions(event) {
const target = event.target;
if (target.classList.contains('reasoning-toggle')) {
const targetId = target.dataset.targetId;
const reasoningDiv = document.getElementById(targetId);
if (reasoningDiv) reasoningDiv.classList.toggle('visible');
return;
}
if (!target.classList.contains('action-icon')) return;
const action = target.dataset.action;
const contentWrapper = target.closest('.message-content-wrapper'); if (!contentWrapper) return;
const messageDiv = contentWrapper.closest('.message'); if (!messageDiv) return;
const messageId = messageDiv.dataset.messageId;
console.log(操作: ${action}, ID: ${messageId});
switch (action) {
case 'edit': handleEdit(messageId, messageDiv, contentWrapper); break;
case 'delete': handleDelete(messageId, messageDiv); break;
case 'regenerate': handleRegenerate(messageId); break;
default: console.warn("未知操作:", action);
}
}

/**

处理编辑消息 (无修改)
*/
function handleEdit(messageId, messageDiv, contentWrapper) {
const messageIndex = messages.findIndex(msg => msg.id === messageId); if (messageIndex === -1) return;
const message = messages[messageIndex];
const messageBubble = contentWrapper.querySelector('.message-bubble');
const contentDiv = messageBubble?.querySelector('.actual-content');
const actionsDiv = contentWrapper.querySelector('.message-actions');
if (!messageBubble || !contentDiv || messageBubble.classList.contains('editing')) return;
if (actionsDiv) actionsDiv.style.display = 'none';
const originalContent = message.content;
messageBubble.classList.add('editing');
const editTextArea = document.createElement('textarea');
editTextArea.className = 'edit-textarea'; editTextArea.value = originalContent;
const editActionsDiv = document.createElement('div'); editActionsDiv.className = 'edit-actions';
const saveBtn = document.createElement('button'); saveBtn.textContent = '保存'; saveBtn.className = 'save-edit-btn';
saveBtn.onclick = () => {
const newContent = editTextArea.value.trim();
if (newContent && newContent !== originalContent) {
messages[messageIndex].content = newContent; renderMarkdown(contentDiv, newContent);
saveConversationToLocalStorage(); console.log("编辑已保存, ID:", messageId);
} else { renderMarkdown(contentDiv, originalContent); console.log("编辑取消, ID:", messageId); }
if (messageBubble.contains(editTextArea)) messageBubble.removeChild(editTextArea);
if (messageBubble.contains(editActionsDiv)) messageBubble.removeChild(editActionsDiv);
if (!messageBubble.contains(contentDiv)) messageBubble.appendChild(contentDiv);
messageBubble.classList.remove('editing'); if (actionsDiv) actionsDiv.style.display = '';
};
const cancelBtn = document.createElement('button'); cancelBtn.textContent = '取消'; cancelBtn.className = 'cancel-edit-btn';
cancelBtn.onclick = () => {
renderMarkdown(contentDiv, originalContent);
if (messageBubble.contains(editTextArea)) messageBubble.removeChild(editTextArea);
if (messageBubble.contains(editActionsDiv)) messageBubble.removeChild(editActionsDiv);
if (!messageBubble.contains(contentDiv)) messageBubble.appendChild(contentDiv);
messageBubble.classList.remove('editing'); if (actionsDiv) actionsDiv.style.display = '';
console.log("编辑已取消, ID:", messageId);
};
editActionsDiv.append(saveBtn, cancelBtn);
if (messageBubble.contains(contentDiv)) messageBubble.removeChild(contentDiv);
messageBubble.append(editTextArea, editActionsDiv);
editTextArea.focus(); adjustTextareaHeight(editTextArea);
editTextArea.addEventListener('input', () => adjustTextareaHeight(editTextArea));
}

/**

处理删除消息 (无修改)
*/
function handleDelete(messageId, messageDiv) {
if (!document.body.contains(messageDiv)) return;
if (confirm("确定删除?")) {
const messageIndex = messages.findIndex(msg => msg.id === messageId);
if (messageIndex !== -1) { messages.splice(messageIndex, 1); saveConversationToLocalStorage(); }
else { console.warn("数组中未找到要删除的消息, ID:", messageId); }
if (messageDiv.parentNode) messageDiv.remove();
console.log("消息已删除, ID:", messageId);
}
}

/**

处理重新生成 AI 消息 (无修改)
*/
async function handleRegenerate(messageId) {
if (sendButton.disabled) { alert("请等待响应完成。"); return; }
const messageIndex = messages.findIndex(msg => msg.id === messageId);
if (messageIndex === -1 || messages[messageIndex].role !== 'assistant') { console.error("无效消息或非AI消息, ID:", messageId); return; }
if (messageIndex === 0 || messages[messageIndex - 1].role !== 'user') { alert("无法重新生成首条或非用户提问后的消息。"); return; }
console.log("准备重新生成, ID:", messageId);
messages.splice(messageIndex, 1); saveConversationToLocalStorage();
const aiMessageDiv = chatContainer?.querySelector(.message[data-message-id="${messageId}"]);
if (aiMessageDiv?.parentNode) aiMessageDiv.remove();
else console.warn("未找到要移除的旧AI消息UI, ID:", messageId);
toggleSendButton(false);
try { await sendRequestToDeepSeekAPI(); }
catch (error) { console.error("重新生成出错:", error); }
}

// --- 对话存储与加载 ---

/**

保存对话到文件 (无修改)
*/
function saveConversationToFile() {
if (messages.length === 0) { alert("对话为空。"); return; }
try {
const settingsToSave = getCurrentSettings();
const conversationData = { version: 1, timestamp: new Date().toISOString(), settings: settingsToSave, history: messages };
const jsonString = JSON.stringify(conversationData, null, 2);
const blob = new Blob([jsonString], { type: 'application/json' });
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url; a.download = deepseek_chat_${new Date().toISOString().slice(0, 19).replace(/[-:T]/g, '')}.json;
document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
console.log("对话已保存。");
} catch (error) { console.error("保存失败:", error); alert("保存失败: " + error.message); }
}

/**

从文件加载对话 (无修改)
*/
function loadConversationFromFile(event) {
const file = event.target.files[0]; if (!file) return;
if (!confirm("加载将覆盖当前对话和设置，确定?")) { event.target.value = ''; return; }
const reader = new FileReader();
reader.onload = (e) => {
try {
const loadedData = JSON.parse(e.target.result);
if (!loadedData || !(Array.isArray(loadedData.history) || Array.isArray(loadedData))) throw new Error("无效格式。");
let loadedMessages = Array.isArray(loadedData) ? loadedData : (loadedData.history || []);
let loadedSettings = Array.isArray(loadedData) ? null : loadedData.settings;
messages = loadedMessages.map(msg => ({ ...msg, id: msg.id || generateUniqueId(msg.role) }));
if(chatContainer) chatContainer.innerHTML = ''; else console.error("加载时 chatContainer 不存在!");
if (loadedSettings) { applySettings(loadedSettings); saveSettings(); console.log("设置已加载。"); }
else { console.log("未找到设置，应用默认。"); applyDefaultSettings(); }
messages.forEach(msg => appendMessageToUI(msg));
saveConversationToLocalStorage(); scrollChatToBottom();
console.log("对话已加载。"); alert("加载成功！");
} catch (error) {
console.error("加载失败:", error); alert("加载失败: " + error.message);
messages = []; if(chatContainer) chatContainer.innerHTML = '';
saveConversationToLocalStorage(); applyDefaultSettings();
} finally { event.target.value = ''; }
};
reader.onerror = (e) => { console.error("读取文件失败:", e); alert("读取失败。"); event.target.value = ''; };
reader.readAsText(file);
}

/**

保存对话到 LocalStorage (无修改)
*/
function saveConversationToLocalStorage() {
try { localStorage.setItem('deepseekChatHistory', JSON.stringify(messages)); }
catch (error) { console.error("保存到LocalStorage失败:", error); if (error.name === 'QuotaExceededError') alert("存储空间已满。");}
}

/**

从 LocalStorage 加载对话 (无修改)
*/
function loadConversationFromLocalStorage() {
try {
const savedHistory = localStorage.getItem('deepseekChatHistory');
if (savedHistory) {
messages = JSON.parse(savedHistory).map(msg => ({ ...msg, id: msg.id || generateUniqueId(msg.role) }));
console.log(加载了 ${messages.length} 条历史.);
if(chatContainer) chatContainer.innerHTML = ''; else console.error("加载历史时 chatContainer 不存在!");
messages.forEach(msg => appendMessageToUI(msg)); scrollChatToBottom();
} else { console.log("未找到历史。"); }
} catch (error) {
console.error("加载历史失败:", error); localStorage.removeItem('deepseekChatHistory');
messages = []; if(chatContainer) chatContainer.innerHTML = '';
}
}

/**

清空对话 (修复版)
*/
function clearConversation() {
if (sendButton?.disabled && currentAbortController) {
if (!confirm("AI 正在响应，确定中止并清空?")) return;
console.log("用户请求中止并清空...");
currentAbortController.abort("User cleared conversation.");
} else if (messages.length === 0) { alert("对话已空。"); return; }
else { if (!confirm("确定清空所有记录?")) return; }
console.log("执行清空...");
messages = [];
currentAssistantMessageId = null; currentAssistantMessageDiv = null;
currentReasoningDiv = null; currentContentDiv = null; currentAbortController = null;
toggleSendButton(true);
if (chatContainer) chatContainer.innerHTML = ''; else console.error("清空时 chatContainer 不存在!");
saveConversationToLocalStorage();
console.log("对话已清空。");
}

// --- 设置管理 ---

/**

获取当前设置 (无修改)
*/
function getCurrentSettings() {
return {
model: modelSelect.value, temperature: parseFloat(temperatureSlider.value),
frequency_penalty: parseFloat(frequencyPenaltySlider.value),
selectedPromptValue: predefinedPromptSelect.value,
systemPromptContent: systemPromptInput.value,
reasoningDefaultVisible: reasoningDefaultVisibleCheckbox.checked
};
}

/**

应用设置 (无修改)
*/
function applySettings(settings) {
console.log("应用设置:", settings);
if (settings.model !== undefined) modelSelect.value = settings.model;
if (settings.temperature !== undefined) { temperatureSlider.value = settings.temperature; updateSliderValue(temperatureSlider, tempValueSpan); }
if (settings.frequency_penalty !== undefined) { frequencyPenaltySlider.value = settings.frequency_penalty; updateSliderValue(frequencyPenaltySlider, penaltyValueSpan); }
let appliedPrompt = false;
if (settings.selectedPromptValue !== undefined) {
const isValid = Array.from(predefinedPromptSelect.options).some(opt => opt.value === settings.selectedPromptValue);
if (isValid) {
predefinedPromptSelect.value = settings.selectedPromptValue; handlePredefinedPromptChange();
if (settings.selectedPromptValue === customPromptValue && settings.systemPromptContent !== undefined) {
systemPromptInput.value = settings.systemPromptContent; adjustTextareaHeight(systemPromptInput);
} appliedPrompt = true;
} else { console.warn("加载了无效的 selectedPromptValue:", settings.selectedPromptValue); }
}
if (!appliedPrompt) { predefinedPromptSelect.selectedIndex = 0; handlePredefinedPromptChange(); }
if (settings.reasoningDefaultVisible !== undefined) reasoningDefaultVisibleCheckbox.checked = settings.reasoningDefaultVisible;
}

/**

应用默认设置 (无修改)
*/
function applyDefaultSettings() {
console.log("应用默认设置。");
modelSelect.value = "deepseek-reasoner"; temperatureSlider.value = 0.7; frequencyPenaltySlider.value = 0.5;
updateSliderValue(temperatureSlider, tempValueSpan); updateSliderValue(frequencyPenaltySlider, penaltyValueSpan);
predefinedPromptSelect.selectedIndex = 0; handlePredefinedPromptChange();
reasoningDefaultVisibleCheckbox.checked = true;
}

/**

保存设置到 LocalStorage (无修改)
*/
function saveSettings() {
try {
const currentSettings = getCurrentSettings(); currentSettings.apiKey = apiKeyInput.value;
localStorage.setItem('deepseekChatSettings', JSON.stringify(currentSettings));
} catch (error) { console.error("保存设置失败:", error); }
}

/**

从 LocalStorage 加载设置 (无修改)
*/
function loadSettings() {
try {
const savedSettings = localStorage.getItem('deepseekChatSettings');
if (savedSettings) {
const loadedSettings = JSON.parse(savedSettings);
applySettings(loadedSettings); if (loadedSettings.apiKey) apiKeyInput.value = loadedSettings.apiKey;
console.log("设置已加载。");
} else { console.log("未找到设置，应用默认。"); applyDefaultSettings(); }
} catch (error) { console.error("加载设置失败:", error); localStorage.removeItem('deepseekChatSettings'); applyDefaultSettings();}
}

// --- 设置弹窗控制 ---
function openSettingsModal() { if (settingsModal) settingsModal.style.display = 'block'; }
function closeSettingsModal() { if (settingsModal) settingsModal.style.display = 'none'; }

// --- 工具函数 ---
function generateUniqueId(prefix = 'msg') { return ${prefix}-${Date.now()}-${Math.random().toString(36).substring(2, 9)}; }

css：

/* --- 全局样式 --- /
body {
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
margin: 0;
padding: 0;
background-color: #f4f7f9;
display: flex;
justify-content: center;
align-items: center;
min-height: 100vh;
color: #333;
/ 防止移动端奇怪的缩放 */
overflow-x: hidden;
}

.app-container {
display: flex;
/* 宽度占满，左右留边距，适合移动端 /
width: 100%;
max-width: 1200px; / 最大宽度限制 /
height: 100vh; / 占据整个视口高度 /
max-height: 100vh; / 确保不超过视口 /
background-color: #fff;
box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
/ 移除圆角和溢出隐藏，让其占满屏幕 /
/ border-radius: 10px; /
/ overflow: hidden; /
box-sizing: border-box; / 包含边框和内边距在宽高内 */
}

/* --- 聊天区域 --- /
.chat-area {
flex-grow: 1; / 占据所有可用空间 /
width: 100%; / 确保宽度占满 /
display: flex;
flex-direction: column;
background-color: #ffffff;
height: 100%; / 确保聊天区域占满容器高度 */
max-height: 100vh;
}

/* 聊天区域头部，用于放置按钮等 /
.chat-header {
display: flex;
justify-content: flex-end; / 将按钮推到右侧 */
padding: 10px 20px;
border-bottom: 1px solid #e0e0e0;
background-color: #f8f9fa;
}

#settings-button {
background: none;
border: none;
font-size: 1.4em; /* 图标大小 */
color: #555;
cursor: pointer;
padding: 5px;
}
#settings-button:hover {
color: #007bff;
}

/* --- 聊天容器 --- /
#chat-container {
flex-grow: 1; / 占据中间的主要空间 /
overflow-y: auto; / 内容超出时滚动 /
padding: 20px;
display: flex;
flex-direction: column;
gap: 15px; / 消息间距 */
}

/* --- 消息通用样式 --- /
.message {
display: flex;
align-items: flex-start; / 头像和内容顶部对齐 /
max-width: 85%;
/ position: relative; / / 相对定位移到 wrapper 上 */
}

.message .avatar {
width: 40px;
height: 40px;
border-radius: 50%;
margin-right: 10px;
flex-shrink: 0; /* 防止头像缩放 */
}

.message-content-wrapper {
display: flex;
flex-direction: column;
flex-grow: 1;
position: relative; /* 设置为相对定位，作为操作按钮的定位基准 /
padding-bottom: 25px; / 增加底部内边距，为操作按钮留出空间，解决悬停问题 /
min-width: 0; / 防止 flex item 内容溢出 */
}

.message-bubble {
padding: 12px 18px;
border-radius: 18px;
word-wrap: break-word;
overflow-wrap: break-word;
line-height: 1.5;
position: relative;
max-width: 100%;
box-sizing: border-box;
}

/* --- 用户消息样式 --- /
.message.user {
align-self: flex-end; / 用户消息靠右 /
flex-direction: row-reverse; / 头像在右 */
}

.message.user .avatar {
margin-right: 0;
margin-left: 10px;
}

.message.user .message-bubble {
background-color: #007bff;
color: #fff;
border-bottom-right-radius: 5px; /* 小尾巴效果 */
}
.message.user .message-bubble a {
color: #e0f7ff;
text-decoration: underline;
}

/* --- AI 消息样式 --- /
.message.assistant {
align-self: flex-start; / AI 消息靠左 */
}

.message.assistant .message-bubble {
background-color: #e9ecef;
color: #333;
border-bottom-left-radius: 5px; /* 小尾巴效果 */
}
.message.assistant .message-bubble a {
color: #0056b3;
text-decoration: underline;
}

/* --- 思维链 (Reasoning) 样式 --- /
.reasoning-content {
background-color: #f0f0f0;
padding: 10px 15px;
margin-bottom: 8px;
border-radius: 10px;
font-size: 0.9em;
color: #555;
border-left: 3px solid #007bff;
white-space: pre-wrap;
display: none; / 默认隐藏 */
box-sizing: border-box;
max-width: 100%;
overflow-wrap: break-word;
word-wrap: break-word;
}

.reasoning-content.visible {
display: block; /* 显示 */
}

.reasoning-toggle {
font-size: 0.8em;
color: #007bff;
cursor: pointer;
margin-bottom: 5px;
display: block;
}
.reasoning-toggle:hover {
text-decoration: underline;
}

.actual-content {
white-space: pre-wrap;
box-sizing: border-box;
max-width: 100%;
overflow-wrap: break-word;
word-wrap: break-word;
}
/* Markdown basic styling (保持不变) */
.actual-content code { background-color: #eee; padding: 2px 4px; border-radius: 3px; font-family: monospace; }
.actual-content pre { background-color: #2d2d2d; color: #f0f0f0; padding: 15px; border-radius: 5px; overflow-x: auto; white-space: pre; }
.actual-content pre code { background-color: transparent; padding: 0; }
.actual-content strong, .actual-content b { font-weight: bold; }
.actual-content em, .actual-content i { font-style: italic; }
.actual-content ul, .actual-content ol { margin-left: 20px; padding-left: 10px; }
.actual-content blockquote { border-left: 3px solid #ccc; padding-left: 10px; margin-left: 0; color: #666; }

/* --- 消息操作按钮 --- /
.message-actions {
position: absolute;
/ 定位在 content-wrapper 的底部，留一点间隙 /
bottom: 5px;
display: none; / 默认隐藏 /
gap: 8px;
background: rgba(248, 249, 250, 0.9); / 背景色稍微明显一点 /
padding: 4px 8px; / 微调内边距 /
border-radius: 15px; / 圆角 /
box-shadow: 0 1px 4px rgba(0,0,0,0.15);
z-index: 1; / 确保在气泡之上（如果需要） */
}

/* 修改悬停目标为 wrapper /
.message-content-wrapper:hover .message-actions {
display: flex; / 悬停在 wrapper 上时显示 */
}

/* 根据消息角色调整左右位置 /
.message.user .message-actions {
right: 10px; / 调整右侧距离 */
}

.message.assistant .message-actions {
left: 10px; /* 调整左侧距离 */
}

.action-icon {
cursor: pointer;
color: #555;
font-size: 0.9em;
transition: color 0.2s ease;
}

.action-icon:hover {
color: #007bff;
}

.action-icon.delete-btn:hover {
color: #dc3545; /* 删除按钮红色 */
}

/* 用户消息隐藏重新生成按钮 /
.message.user .regenerate-btn {
display: none;
}
/ 用户消息隐藏思维链开关 */
.message.user .reasoning-toggle {
display: none;
}

/* --- 消息输入区域 --- /
#message-input-container {
display: flex;
padding: 10px 15px; / 减少一点内边距 /
border-top: 1px solid #e0e0e0;
background-color: #f8f9fa;
align-items: flex-end; / 底部对齐，当输入框增高时按钮仍在底部 */
}

#user-input {
flex-grow: 1;
padding: 10px 15px; /* 调整内边距 /
border: 1px solid #ccc;
border-radius: 20px;
resize: none;
font-size: 1em;
margin-right: 10px;
height: auto;
min-height: 22px; / 调整最小高度以匹配行高 */
max-height: 150px;
overflow-y: auto;
line-height: 1.4;
box-sizing: border-box;
}

#send-button {
background-color: #007bff;
color: white;
border: none;
border-radius: 50%;
width: 40px; /* 稍微缩小按钮 /
height: 40px;
font-size: 1.1em; / 调整图标大小 */
cursor: pointer;
display: flex;
justify-content: center;
align-items: center;
transition: background-color 0.2s ease;
flex-shrink: 0;
}

#send-button:hover {
background-color: #0056b3;
}
#send-button:disabled {
background-color: #cccccc;
cursor: not-allowed;
}

/* --- 存储控制按钮 --- /
.storage-controls {
padding: 10px 15px; / 减少内边距 /
border-top: 1px solid #e0e0e0;
background-color: #f8f9fa;
display: flex;
justify-content: flex-start;
gap: 10px;
flex-wrap: wrap; / 允许换行 */
}

.storage-controls button, .load-button {
padding: 8px 12px; /* 调整按钮大小 /
border: 1px solid #ccc;
background-color: #fff;
border-radius: 5px;
cursor: pointer;
font-size: 0.9em;
display: inline-flex;
align-items: center;
gap: 5px;
transition: background-color 0.2s, border-color 0.2s;
}
.storage-controls button:hover, .load-button:hover {
background-color: #e9ecef;
border-color: #bbb;
}
#clear-button {
margin-left: auto; / 保持清空按钮在右侧（如果空间足够）*/
border-color: #dc3545;
color: #dc3545;
}
#clear-button:hover {
background-color: #dc3545;
color: #fff;
}

/* --- 编辑状态 --- /
.message-bubble.editing { padding: 0; }
.edit-textarea { width: 100%; min-height: 50px; border: 1px dashed #007bff; border-radius: 5px; padding: 10px; font-family: inherit; font-size: inherit; line-height: inherit; box-sizing: border-box; resize: vertical; }
.edit-actions { margin-top: 5px; display: flex; gap: 5px; padding: 0 10px 5px; } / 给按钮一点边距 */
.edit-actions button { padding: 3px 8px; font-size: 0.8em; cursor: pointer; border-radius: 3px; }
.save-edit-btn { background-color: #28a745; color: white; border: 1px solid #28a745; }
.cancel-edit-btn { background-color: #6c757d; color: white; border: 1px solid #6c757d; }

/* --- 设置模态弹窗样式 --- /
.modal {
display: none; / 默认隐藏 /
position: fixed; / 固定定位，覆盖整个屏幕 /
z-index: 1000; / 确保在最上层 /
left: 0;
top: 0;
width: 100%;
height: 100%;
overflow: auto; / 如果内容超长则允许滚动 /
background-color: rgba(0, 0, 0, 0.5); / 半透明黑色背景 /
animation: fadeIn 0.3s ease-out; / 淡入动画 */
}

.modal-content {
background-color: #fefefe;
margin: 10% auto; /* 上下 10% 边距，左右自动居中 /
padding: 25px 30px;
border: 1px solid #888;
width: 80%; / 响应式宽度 /
max-width: 500px; / 最大宽度 /
border-radius: 8px;
position: relative;
box-shadow: 0 5px 15px rgba(0,0,0,0.2);
animation: slideIn 0.3s ease-out; / 滑入动画 */
}

.close-button {
color: #aaa;
position: absolute;
top: 10px;
right: 20px;
font-size: 28px;
font-weight: bold;
}

.close-button:hover,
.close-button:focus {
color: black;
text-decoration: none;
cursor: pointer;
}

.modal h2 {
text-align: center;
margin-top: 0;
margin-bottom: 25px;
color: #555;
font-size: 1.4em;
}

/* 继承 settings-panel 的内部样式 */
.modal .setting-item { margin-bottom: 20px; }
.modal .setting-item label { display: block; margin-bottom: 8px; font-weight: 600; color: #444; font-size: 0.9em; }
.modal .setting-item input[type="password"],
.modal .setting-item select,
.modal .setting-item textarea { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px; box-sizing: border-box; font-size: 0.9em; }
.modal .setting-item input[type="checkbox"] { margin-right: 5px; vertical-align: middle; }
.modal .setting-item textarea { resize: vertical; min-height: 60px; }
.modal .setting-item input[type="range"] { width: 100%; cursor: pointer; }
.modal .setting-item span { font-weight: normal; color: #007bff; }

/* 动画效果 */
@keyframes fadeIn {
from { opacity: 0; }
to { opacity: 1; }
}
@keyframes slideIn {
from { transform: translateY(-30px); opacity: 0; }
to { transform: translateY(0); opacity: 1; }
}

/* --- 滚动条美化 (保持不变) --- */
::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
::-webkit-scrollbar-thumb { background: #ccc; border-radius: 10px; }
::-webkit-scrollbar-thumb:hover { background: #aaa; }

/* 响应式调整：小屏幕时内边距小一些 /
@media (max-width: 600px) {
.app-container {
height: 100vh; / 在小屏幕上强制占满 /
max-height: 100vh;
box-shadow: none; / 可以去掉阴影 /
}
#chat-container {
padding: 10px; / 减少内边距 /
}
#message-input-container {
padding: 8px 10px;
}
.storage-controls {
padding: 8px 10px;
}
.message .avatar {
width: 35px; / 头像小一点 /
height: 35px;
margin-right: 8px;
}
.message.user .avatar {
margin-left: 8px;
}
.message-content-wrapper {
padding-bottom: 28px; / 确保按钮空间 /
}
.message-actions {
gap: 6px; / 图标间距小一点 /
padding: 3px 6px;
}
.message.user .message-actions {
right: 5px;
}
.message.assistant .message-actions {
left: 5px;
}
.modal-content {
width: 90%; / 弹窗宽度更大 /
margin: 15% auto; / 调整垂直边距 */
padding: 20px;
}
.modal h2 {
font-size: 1.2em;
}
}

参考代码：
Body

required

messages

object[]

required

model
string
required
Possible values: [deepseek-chat, deepseek-reasoner]

使用的模型的 ID。您可以使用 deepseek-chat。

frequency_penalty
number
nullable
Possible values: >= -2 and <= 2

Default value: 0

介于 -2.0 和 2.0 之间的数字。如果该值为正，那么新 token 会根据其在已有文本中的出现频率受到相应的惩罚，降低模型重复相同内容的可能性。

max_tokens
integer
nullable
Possible values: > 1

介于 1 到 8192 间的整数，限制一次请求中模型生成 completion 的最大 token 数。输入 token 和输出 token 的总长度受模型的上下文长度的限制。

如未指定 max_tokens参数，默认使用 4096。

presence_penalty
number
nullable
Possible values: >= -2 and <= 2

Default value: 0

介于 -2.0 和 2.0 之间的数字。如果该值为正，那么新 token 会根据其是否已在已有文本中出现受到相应的惩罚，从而增加模型谈论新主题的可能性。

response_format

object

nullable

stop

object

nullable

stream
boolean
nullable
如果设置为 True，将会以 SSE（server-sent events）的形式以流式发送消息增量。消息流以 data: [DONE] 结尾。

stream_options

object

nullable

temperature
number
nullable
Possible values: <= 2

Default value: 1

采样温度，介于 0 和 2 之间。更高的值，如 0.8，会使输出更随机，而更低的值，如 0.2，会使其更加集中和确定。 我们通常建议可以更改这个值或者更改 top_p，但不建议同时对两者进行修改。

top_p
number
nullable
Possible values: <= 1

Default value: 1

作为调节采样温度的替代方案，模型会考虑前 top_p 概率的 token 的结果。所以 0.1 就意味着只有包括在最高 10% 概率中的 token 会被考虑。 我们通常建议修改这个值或者更改 temperature，但不建议同时对两者进行修改。

tools

object[]

nullable

模型可能会调用的 tool 的列表。目前，仅支持 function 作为工具。使用此参数来提供以 JSON 作为输入参数的 function 列表。最多支持 128 个 function。

Array [

type
string
required
Possible values: [function]

tool 的类型。目前仅支持 function。

function

object

required

]

tool_choice

object

nullable

控制模型调用 tool 的行为。

none 意味着模型不会调用任何 tool，而是生成一条消息。

auto 意味着模型可以选择生成一条消息或调用一个或多个 tool。

required 意味着模型必须调用一个或多个 tool。

通过 {"type": "function", "function": {"name": "my_function"}} 指定特定 tool，会强制模型调用该 tool。

当没有 tool 时，默认值为 none。如果有 tool 存在，默认值为 auto。

oneOf

ChatCompletionToolChoice
ChatCompletionNamedToolChoice
string

Possible values: [none, auto, required]

logprobs
boolean
nullable
是否返回所输出 token 的对数概率。如果为 true，则在 message 的 content 中返回每个输出 token 的对数概率。

top_logprobs
integer
nullable
Possible values: <= 20

一个介于 0 到 20 之间的整数 N，指定每个输出位置返回输出概率 top N 的 token，且返回这些 token 的对数概率。指定此参数时，logprobs 必须为 true。